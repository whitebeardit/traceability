name: Auto Merge Staging PR

on:
  pull_request_review:
    types: [submitted]

concurrency:
  group: auto-merge-pr-${{ github.event.pull_request.number }}
  cancel-in-progress: false

jobs:
  auto-merge:
    if: |
      github.event.pull_request.base.ref == 'main' &&
      github.event.pull_request.head.ref == 'staging' &&
      github.event.review.state == 'approved'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: Verificar label staging-sync
        id: check-label
        uses: actions/github-script@v7
        with:
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            const hasLabel = pr.data.labels.some(label => label.name === 'staging-sync');
            if (!hasLabel) {
              core.setFailed('PR não tem label staging-sync');
            }
            core.setOutput('has_label', hasLabel);
      
      - name: Verificar aprovação válida
        id: check-approval
        uses: actions/github-script@v7
        with:
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            // Verificar se revisor não é o autor
            if (context.payload.review.user.login === pr.data.user.login) {
              core.setFailed('Autor não pode aprovar sua própria PR');
            }
            
            // Verificar se há reviews negativos
            const reviews = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            const hasRequestChanges = reviews.data.some(r => 
              r.state === 'CHANGES_REQUESTED' && 
              r.user.login !== pr.data.user.login &&
              r.submitted_at > context.payload.review.submitted_at
            );
            
            if (hasRequestChanges) {
              core.setFailed('PR tem solicitações de mudanças pendentes');
            }
      
      - name: Verificar se PR está pronta para merge
        id: check-pr
        uses: actions/github-script@v7
        with:
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            if (pr.data.state !== 'open') {
              core.setFailed('PR não está aberta');
            }
            
            // Verificar se PR está atualizada
            if (pr.data.behind_by > 0) {
              core.setFailed('PR está desatualizada com base branch');
            }
            
            if (pr.data.mergeable === false) {
              core.setFailed('PR não está pronta para merge (conflitos)');
            }
            
            if (pr.data.mergeable_state === 'dirty') {
              core.setFailed('PR tem conflitos de merge');
            }
            
            // Aguardar checks com timeout (5 minutos)
            const maxWaitTime = 300000;
            const startTime = Date.now();
            const requiredChecks = ['build-and-test-net8', 'build-and-test-net48'];
            
            while (Date.now() - startTime < maxWaitTime) {
              const checks = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.data.head.sha
              });
              
              const allCompleted = requiredChecks.every(checkName => {
                const check = checks.data.check_runs.find(c => c.name === checkName);
                return check && check.status === 'completed';
              });
              
              if (allCompleted) {
                const allPassed = requiredChecks.every(checkName => {
                  const check = checks.data.check_runs.find(c => c.name === checkName);
                  return check && check.conclusion === 'success';
                });
                
                if (allPassed) {
                  core.info('Todos os checks passaram');
                  break;
                } else {
                  core.setFailed('Alguns checks falharam');
                }
              }
              
              // Aguardar 10 segundos antes de verificar novamente
              await new Promise(resolve => setTimeout(resolve, 10000));
            }
            
            if (Date.now() - startTime >= maxWaitTime) {
              core.setFailed('Timeout aguardando checks');
            }
      
      - name: Merge PR
        uses: peter-evans/merge-pull-request@v2
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          pull-request-number: ${{ github.event.pull_request.number }}
          merge-method: merge
          delete-branch: true
      
      - name: Notificar merge bem-sucedido
        if: success()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: '✅ PR mergeada automaticamente após aprovação!'
            });
      
      - name: Notificar erro
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: context.payload.pull_request.number,
              body: `❌ Merge automático falhou. Verifique os logs do workflow para mais detalhes.`
            });

