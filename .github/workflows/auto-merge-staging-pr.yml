name: Auto Merge Staging PR

on:
  pull_request_review:
    types: [submitted]

concurrency:
  group: auto-merge-pr-${{ github.event.pull_request.number }}
  cancel-in-progress: false

jobs:
  auto-merge:
    if: |
      github.event.pull_request.base.ref == 'main' &&
      github.event.pull_request.head.ref == 'staging' &&
      github.event.review.state == 'approved'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Verificar label staging-sync
        id: check-label
        uses: actions/github-script@v7
        with:
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            const hasLabel = pr.data.labels.some(label => label.name === 'staging-sync');
            if (!hasLabel) {
              core.setFailed('PR não tem label staging-sync');
            }
            core.setOutput('has_label', hasLabel);
      
      - name: Verificar aprovação válida
        id: check-approval
        uses: actions/github-script@v7
        with:
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            // Verificar se revisor não é o autor
            if (context.payload.review.user.login === pr.data.user.login) {
              core.setFailed('Autor não pode aprovar sua própria PR');
            }
            
            // Verificar se há reviews negativos
            // Agrupar reviews pelo revisor e considerar apenas o review mais recente de cada um
            const reviews = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            const latestReviewsByUser = new Map();
            for (const r of reviews.data) {
              if (!r.user || !r.user.login) continue;
              const userLogin = r.user.login;
              
              // Ignorar reviews do autor da PR
              if (userLogin === pr.data.user.login) continue;
              
              const existing = latestReviewsByUser.get(userLogin);
              if (!existing || new Date(r.submitted_at) > new Date(existing.submitted_at)) {
                latestReviewsByUser.set(userLogin, r);
              }
            }
            
            const hasRequestChanges = Array.from(latestReviewsByUser.values()).some(r =>
              r.state === 'CHANGES_REQUESTED'
            );
            
            if (hasRequestChanges) {
              core.setFailed('PR tem solicitações de mudanças pendentes');
            }
      
      - name: Verificar se PR está pronta para merge
        id: check-pr
        uses: actions/github-script@v7
        with:
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            if (pr.data.state !== 'open') {
              core.setFailed('PR não está aberta');
            }
            
            // Verificar se PR está pronta para merge em relação ao estado de merge
            if (pr.data.mergeable === false) {
              core.setFailed('PR não está pronta para merge (conflitos ou estado inválido)');
            }
            
            // Verificar se PR está desatualizada ou com conflitos segundo mergeable_state
            if (pr.data.mergeable_state === 'behind' || pr.data.mergeable_state === 'dirty') {
              core.setFailed('PR está desatualizada com a base ou tem conflitos de merge');
            }
            
            // Aguardar checks com timeout (5 minutos)
            const maxWaitTime = 300000;
            const startTime = Date.now();
            const requiredChecks = ['build-and-test-net8', 'build-and-test-net48'];
            
            while (Date.now() - startTime < maxWaitTime) {
              const checks = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.data.head.sha
              });
              
              const allCompleted = requiredChecks.every(checkName => {
                const check = checks.data.check_runs.find(c => c.name === checkName);
                return check && check.status === 'completed';
              });
              
              if (allCompleted) {
                const allPassed = requiredChecks.every(checkName => {
                  const check = checks.data.check_runs.find(c => c.name === checkName);
                  return check && check.conclusion === 'success';
                });
                
                if (allPassed) {
                  core.info('Todos os checks passaram');
                  break;
                } else {
                  core.setFailed('Alguns checks falharam');
                }
              }
              
              // Aguardar 10 segundos antes de verificar novamente (sempre, não apenas quando completos)
              await new Promise(resolve => setTimeout(resolve, 10000));
            }
            
            if (Date.now() - startTime >= maxWaitTime) {
              core.setFailed('Timeout aguardando checks');
            }
      
      - name: Merge PR
        id: merge-pr
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER);
            
            // Fazer merge da PR
            const mergeResult = await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              merge_method: 'merge'
            });
            
            core.info(`PR #${prNumber} mergeada com sucesso`);
            
            // Tentar deletar a branch (pode falhar se já foi deletada ou se há proteções)
            try {
              await github.rest.git.deleteRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `heads/${context.payload.pull_request.head.ref}`
              });
              core.info(`Branch ${context.payload.pull_request.head.ref} deletada`);
            } catch (error) {
              core.warning(`Não foi possível deletar a branch: ${error.message}`);
            }
      
      - name: Notificar merge bem-sucedido
        if: success()
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
        with:
          script: |
            try {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(process.env.PR_NUMBER),
                body: '✅ PR mergeada automaticamente após aprovação!'
              });
            } catch (error) {
              core.warning(`Não foi possível comentar na PR: ${error.message}`);
            }
      
      - name: Notificar erro
        if: failure()
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
        with:
          script: |
            try {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(process.env.PR_NUMBER),
                body: `❌ Merge automático falhou. Verifique os logs do workflow para mais detalhes.`
              });
            } catch (error) {
              core.warning(`Não foi possível comentar na PR: ${error.message}`);
            }

