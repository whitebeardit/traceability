name: Auto Merge Staging PR

on:
  pull_request_review:
    types: [submitted]

concurrency:
  group: auto-merge-pr-${{ github.event.pull_request.number }}
  cancel-in-progress: false

jobs:
  auto-merge:
    if: |
      github.event.pull_request.base.ref == 'main' &&
      github.event.pull_request.head.ref == 'staging' &&
      github.event.review.state == 'approved'
    runs-on: ubuntu-latest
    permissions:
      contents: write
      pull-requests: write
    steps:
      - name: Verificar label staging-sync
        id: check-label
        uses: actions/github-script@v7
        with:
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            const hasLabel = pr.data.labels.some(label => label.name === 'staging-sync');
            if (!hasLabel) {
              core.setFailed('PR não tem label staging-sync');
            }
            core.setOutput('has_label', hasLabel);
      
      - name: Verificar aprovação válida
        id: check-approval
        uses: actions/github-script@v7
        with:
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            // Verificar se revisor não é o autor
            if (context.payload.review.user.login === pr.data.user.login) {
              core.setFailed('Autor não pode aprovar sua própria PR');
            }
            
            // Verificar se há reviews negativos
            // Agrupar reviews pelo revisor e considerar apenas o review mais recente de cada um
            const reviews = await github.rest.pulls.listReviews({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            const latestReviewsByUser = new Map();
            for (const r of reviews.data) {
              if (!r.user || !r.user.login) continue;
              const userLogin = r.user.login;
              
              // Ignorar reviews do autor da PR
              if (userLogin === pr.data.user.login) continue;
              
              const existing = latestReviewsByUser.get(userLogin);
              if (!existing || new Date(r.submitted_at) > new Date(existing.submitted_at)) {
                latestReviewsByUser.set(userLogin, r);
              }
            }
            
            const hasRequestChanges = Array.from(latestReviewsByUser.values()).some(r =>
              r.state === 'CHANGES_REQUESTED'
            );
            
            if (hasRequestChanges) {
              core.setFailed('PR tem solicitações de mudanças pendentes');
            }
      
      - name: Verificar se PR está pronta para merge
        id: check-pr
        uses: actions/github-script@v7
        with:
          script: |
            const pr = await github.rest.pulls.get({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: context.payload.pull_request.number
            });
            
            if (pr.data.state !== 'open') {
              core.setFailed('PR não está aberta');
            }
            
            // Verificar se PR está pronta para merge em relação ao estado de merge
            if (pr.data.mergeable === false) {
              core.setFailed('PR não está pronta para merge (conflitos ou estado inválido)');
            }
            
            // Verificar se PR está desatualizada ou com conflitos segundo mergeable_state
            if (pr.data.mergeable_state === 'behind' || pr.data.mergeable_state === 'dirty') {
              core.setFailed('PR está desatualizada com a base ou tem conflitos de merge');
            }
            
            // Aguardar checks com timeout (5 minutos)
            const maxWaitTime = 300000;
            const startTime = Date.now();
            const requiredChecks = ['build-and-test-net8', 'build-and-test-net48'];
            
            // #region agent log
            fetch('http://127.0.0.1:7243/ingest/273313cd-687d-4abf-87cf-0cbb24795711',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'auto-merge-staging-pr.yml:110',message:'Iniciando verificação de checks',data:{requiredChecks,prNumber:pr.data.number,headSha:pr.data.head.sha},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A'})}).catch(()=>{});
            // #endregion
            
            while (Date.now() - startTime < maxWaitTime) {
              const checks = await github.rest.checks.listForRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: pr.data.head.sha
              });
              
              // #region agent log
              fetch('http://127.0.0.1:7243/ingest/273313cd-687d-4abf-87cf-0cbb24795711',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'auto-merge-staging-pr.yml:120',message:'Checks encontrados',data:{totalChecks:checks.data.check_runs.length,checkNames:checks.data.check_runs.map(c=>({name:c.name,status:c.status,conclusion:c.conclusion})),requiredChecks},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A,B,C'})}).catch(()=>{});
              // #endregion
              
              const allCompleted = requiredChecks.every(checkName => {
                const check = checks.data.check_runs.find(c => c.name === checkName);
                const found = !!check;
                const completed = check && check.status === 'completed';
                
                // #region agent log
                fetch('http://127.0.0.1:7243/ingest/273313cd-687d-4abf-87cf-0cbb24795711',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'auto-merge-staging-pr.yml:125',message:'Verificando check obrigatório',data:{checkName,found,completed,status:check?.status,conclusion:check?.conclusion},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'A,C'})}).catch(()=>{});
                // #endregion
                
                return completed;
              });
              
              // #region agent log
              fetch('http://127.0.0.1:7243/ingest/273313cd-687d-4abf-87cf-0cbb24795711',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'auto-merge-staging-pr.yml:135',message:'Status de conclusão dos checks',data:{allCompleted,elapsedTime:Date.now()-startTime},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
              // #endregion
              
              if (allCompleted) {
                const checkResults = requiredChecks.map(checkName => {
                  const check = checks.data.check_runs.find(c => c.name === checkName);
                  return {
                    name: checkName,
                    found: !!check,
                    status: check?.status,
                    conclusion: check?.conclusion,
                    passed: check && check.conclusion === 'success'
                  };
                });
                
                // #region agent log
                fetch('http://127.0.0.1:7243/ingest/273313cd-687d-4abf-87cf-0cbb24795711',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'auto-merge-staging-pr.yml:145',message:'Resultados detalhados dos checks',data:{checkResults,allChecks:checks.data.check_runs.map(c=>({name:c.name,status:c.status,conclusion:c.conclusion}))},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B,E'})}).catch(()=>{});
                // #endregion
                
                const allPassed = checkResults.every(r => r.passed);
                
                if (allPassed) {
                  // #region agent log
                  fetch('http://127.0.0.1:7243/ingest/273313cd-687d-4abf-87cf-0cbb24795711',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'auto-merge-staging-pr.yml:155',message:'Todos os checks passaram',data:{checkResults},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
                  // #endregion
                  core.info('Todos os checks passaram');
                  break;
                } else {
                  const failedChecks = checkResults.filter(r => !r.passed && r.conclusion !== 'skipped');
                  const skippedChecks = checkResults.filter(r => r.conclusion === 'skipped');
                  
                  // #region agent log
                  fetch('http://127.0.0.1:7243/ingest/273313cd-687d-4abf-87cf-0cbb24795711',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'auto-merge-staging-pr.yml:162',message:'Checks falharam ou foram pulados - detalhes',data:{failedChecks,skippedChecks,allCheckResults:checkResults},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'B'})}).catch(()=>{});
                  // #endregion
                  
                  if (failedChecks.length > 0) {
                    core.setFailed(`Checks falharam: ${failedChecks.map(c => `${c.name} (${c.conclusion || c.status})`).join(', ')}`);
                  } else if (skippedChecks.length > 0) {
                    // Se todos os checks foram pulados, aguardar mais um pouco ou falhar
                    core.warning(`Checks foram pulados: ${skippedChecks.map(c => c.name).join(', ')}. Aguardando execução...`);
                    // Continuar o loop para aguardar que os checks sejam executados
                  }
                }
              }
              
              // Aguardar 10 segundos antes de verificar novamente (sempre, não apenas quando completos)
              await new Promise(resolve => setTimeout(resolve, 10000));
            }
            
            if (Date.now() - startTime >= maxWaitTime) {
              // #region agent log
              fetch('http://127.0.0.1:7243/ingest/273313cd-687d-4abf-87cf-0cbb24795711',{method:'POST',headers:{'Content-Type':'application/json'},body:JSON.stringify({location:'auto-merge-staging-pr.yml:175',message:'Timeout aguardando checks',data:{elapsedTime:Date.now()-startTime,maxWaitTime},timestamp:Date.now(),sessionId:'debug-session',runId:'run1',hypothesisId:'D'})}).catch(()=>{});
              // #endregion
              core.setFailed('Timeout aguardando checks');
            }
      
      - name: Merge PR
        id: merge-pr
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
        with:
          script: |
            const prNumber = parseInt(process.env.PR_NUMBER);
            
            // Fazer merge da PR
            const mergeResult = await github.rest.pulls.merge({
              owner: context.repo.owner,
              repo: context.repo.repo,
              pull_number: prNumber,
              merge_method: 'merge'
            });
            
            core.info(`PR #${prNumber} mergeada com sucesso`);
            
            // Tentar deletar a branch (pode falhar se já foi deletada ou se há proteções)
            try {
              await github.rest.git.deleteRef({
                owner: context.repo.owner,
                repo: context.repo.repo,
                ref: `heads/${context.payload.pull_request.head.ref}`
              });
              core.info(`Branch ${context.payload.pull_request.head.ref} deletada`);
            } catch (error) {
              core.warning(`Não foi possível deletar a branch: ${error.message}`);
            }
      
      - name: Notificar merge bem-sucedido
        if: success()
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
        with:
          script: |
            try {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(process.env.PR_NUMBER),
                body: '✅ PR mergeada automaticamente após aprovação!'
              });
            } catch (error) {
              core.warning(`Não foi possível comentar na PR: ${error.message}`);
            }
      
      - name: Notificar erro
        if: failure()
        uses: actions/github-script@v7
        env:
          PR_NUMBER: ${{ github.event.pull_request.number }}
        with:
          script: |
            try {
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: parseInt(process.env.PR_NUMBER),
                body: `❌ Merge automático falhou. Verifique os logs do workflow para mais detalhes.`
              });
            } catch (error) {
              core.warning(`Não foi possível comentar na PR: ${error.message}`);
            }

